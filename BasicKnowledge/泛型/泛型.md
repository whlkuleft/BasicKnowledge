object类型参数有2个问题：

```
1.装箱拆箱，传入一个int值（栈）
	object在堆里，如果把int传递进来，就会把值从栈里面copy到堆里
	使用的时候又需要用对象值，又会copy到栈（拆箱），就有性能损耗
2.类型安全问题，Object可以传任何类型进来，没有限制
```

泛型为什么可以支持多种不同类型的参数？

```
方法声明时没有指定类型，T要等调用的时候才指定类型
设计思想--延迟声明：推迟一切可以推迟的，一切能晚点做的就晚点做
```

泛型原理：

```
代码到机器语言的过程
C#->编译器VS(编译)->DLL/EXE(IL中间语言)->CLR（公共语言运行时）/JIT->010101机器语言
到机器语言时，必须确定T的类型，但是在编译(一次编译)时却不知道T是什么类型，只提供了占位符，如,`1 ,`2，所以是在CLR编译成机器码（二次编译）时确定的
泛型不是一个语法糖，是框架升级到2.0才支持的
```



性能：

```
泛型约等于确定类型，远高于Object
一亿次循环装箱intToObject耗时是泛型和确定类型的两倍
```

拓展：

```
泛型缓存：每个类型对象都有一个该类型的副本（静态资源以类型为单位的副本）
```

泛型约束类型：

```
基类约束：Where T:People 可以把T当成积累，传入类型必须是其本身或子类
接口约束：Where T:ISports 只有实现T所
引用类型约束：Where T:class
值类型约束: Where T:struct
无参构造函数约束： Where T:new()
返回默认值：return default(T) //default是个关键字，会根据T的类型去获得一个默认值
约束可以多个约束类型
```

拓展：协变/逆变

```
out 协变  in 逆变
只有接口和委托才有
3.0出现
协变：new List（右边）可以为子类，让泛型用起来更方便，接口泛型加上out T 则T只能当作返回值，不能当参数
逆变：new List（右边）可以为父类，让泛型用起来更方便，接口泛型加上in T 则T只能当作参数，不能做返回值
```





tips:调用泛型一般需要指定类型参数，如果可以从参数类型推断，可以省略类型参数(语法糖)